---
title: "PCA of duplication metrics"
author: "Claudia Zirión-Martínez"
date: "2025-03-04"
#format: 
#    PrettyPDF-pdf:
#        keep-tex: false
df-print: kable
editor: visual
embed-resources: true
format:
  html:
    code-overflow: wrap
    code-fold: false
fig-height: 7
fig-width: 9
fig-align: center
---

## Get data

```{r, output=FALSE}
#| code-fold: true
library("ggplot2")
library("ggfortify")
library("gridExtra")
library("carData")
library("car")
library("factoextra")
library("corrplot")
library("tidyverse")
setwd("/FastData/czirion/Crypto_Diversity_Pipeline/analyses/tree_duplications/scripts")
```

Get the metrics of chromosome copy-number variation.
```{r, message=FALSE, warning=FALSE}
#| code-fold: true
metadata <- read.delim(
    "../../data/processed/metadata_ashton_desj_all_fungalpop_H99.csv",
    header=TRUE,
    sep=",",
    stringsAsFactor = TRUE)
metadata <- metadata %>%
    select(sample, strain, source, lineage, dataset, vni_subdivision)%>%
    filter(!strain == "H99") %>%
    group_by(dataset, lineage)%>%
    mutate(samples_in_dataset_lineage = n_distinct(sample))%>%
    ungroup() %>%
    group_by(lineage)%>%
    mutate(samples_in_lineage = n_distinct(sample))%>%
    ungroup()%>%
    mutate(total_samples = n_distinct(sample))%>%
    droplevels()

chromosome_names = read.delim(
    "../../../Crypto_Desjardins_Ashton/results_joined/02.Dataset/chromosomes.csv",
    header=TRUE, sep=",")
chromosome_names <- chromosome_names %>%
    mutate(chromosome = str_pad(chromosome, 2, pad = "0"))%>%
    mutate(chromosome = as.factor(chromosome))
levels(chromosome_names$chromosome) <- paste("chr", chromosome_names$chromosome, sep="")

chromosome_lengths = read.delim(
    "../../data/processed/chromosome_lengths.tsv", 
    header=FALSE, 
    col.names=c("accession", "length"), 
    sep="\t")

depth_by_chrom_good_desjardins <- read.delim(
    "../../../Crypto_Desjardins/results/04.Intermediate_files/02.Dataset/depth_quality/depth_by_chrom_good.tsv",
     header=TRUE, sep="\t")
depth_by_chrom_good_ashton <- read.delim(
    "../../../Crypto_Ashton/results/04.Intermediate_files/02.Dataset/depth_quality/depth_by_chrom_good.tsv",
     header=TRUE, sep="\t")
depth_by_chrom_good <- rbind(depth_by_chrom_good_desjardins, depth_by_chrom_good_ashton)
depth_by_chrom <- depth_by_chrom_good %>%
    select(sample, accession, norm_chrom_median, norm_chrom_mean)

cnv_calls <- read.delim(
    "../../../Crypto_Desjardins_Ashton/results_joined/02.Dataset/cnv/cnv_calls.tsv", 
    header=TRUE, sep="\t")
dup_calls <- filter(cnv_calls, cnv == "duplication") %>%
    left_join(chromosome_names, by="accession")

dup_calls_filtered <- dup_calls %>%
    filter(!(norm_depth > 10 & repeat_fraction > 0.5)) %>%
    filter(!(chromosome == "chr01" & start > 337000 & start < 340000))

all_metrics <- left_join(depth_by_chrom, dup_calls_filtered, 
        by = c("sample", "accession"))%>%
    select(-chromosome, -lineage)%>%
    left_join(chromosome_lengths, by = "accession") %>%
    left_join(chromosome_names,by ="accession") %>%
    left_join(metadata, by = c("sample", "lineage"))

chrom_metrics <- all_metrics %>%
    group_by(dataset,lineage,
            samples_in_lineage, samples_in_dataset_lineage, 
            total_samples,sample, 
            strain,source,
            accession,chromosome, length, norm_chrom_mean, norm_chrom_median) %>%
    summarise(total_cnv_size = sum(region_size),
                n_cnvs = n(),
                first = min(start),
                last = max(end),
                mean_cnv_depth = round(mean(norm_depth),2),
                median_cnv_depth = round(median(norm_depth),2),
                repeat_size = sum(overlap_bp)) %>%
    ungroup()%>%
    mutate(dup_coverage_percent = round((total_cnv_size / length) * 100, 2),
            dup_span_size = last - first,
            dup_span_percent = round((dup_span_size / length) * 100, 2),
            dup_repeat_percent = round((repeat_size / length) * 100, 2),
            chromosome = as.factor(chromosome),
            dup_coverage_percent = ifelse(is.na(dup_coverage_percent), 0, dup_coverage_percent),
            dup_span_percent = ifelse(is.na(dup_span_percent), 0, dup_span_percent))
```

Option to filter metrics
```{r}
#| code-fold: false
size_threshold <- 50
depth_threshold <- 1.55
```

```{r}
chrom_metrics <- chrom_metrics %>%
    filter(dup_coverage_percent >= size_threshold | norm_chrom_median >= depth_threshold)
```

Chose which variable to analyze

```{r}
# variable <- "norm_chrom_median"
variable <- "dup_coverage_percent"
```

Make the matrix for the selected varible

```{r}
metadata <- metadata %>%
    select(sample,strain,lineage,vni_subdivision,source)%>%
    column_to_rownames("sample")

matrix <- chrom_metrics %>%
    select(sample, chromosome, all_of(variable) )%>%
    pivot_wider(names_from = chromosome, values_from = all_of(variable))%>%
    column_to_rownames("sample")
matrix[is.na(matrix)] <- 0
```

## Run PCA
Compute the PCA with `prcomp()` scaling the data befor analysing.  
The result is in `res.pca` which has the:  
- Standard deviation  
- Value of each PC for each variable  

```{r}
res.pca <- prcomp(matrix, scale = TRUE)
```

The summary shows for each PC:  
- Standar deviation  
- Proportion of variance (Amount of variance explained by each PC)  
- Cumulative proportion  
```{r}
summary(res.pca)
```

The Eigenvalues are how much variance is in each PC.  
And the Variance Percent is (Eigencalue of PC1 / sum(All Eigenvalues)) * 100.  
They can be extracted from `res.pca`.  
```{r}
eig.val<-get_eigenvalue(res.pca)
eig.val
```

### Percent of variance explained by each Dimension
```{r}
fviz_eig(res.pca, col.var="blue")
```

## PCA result for variables
Extract:  
- Coordinate of each variable in each dimension  
- Correlation between variables and dimensions  
- Squared cosine Cos2 of each variable in each dimension  
- Contribution of each variable to each dimension  
```{r}
var <- get_pca_var(res.pca)
```

### Cos2 of each variable in all dimensions
Cos2 is called square cosine (squared coordinates) and corresponds to the quality of representation of variables in a dimension.
Size and color of circles represent the cos2 value. 
```{r}
corrplot(var$cos2, is.corr=FALSE)
```

### Cos 2 of all variables in Dimensions 1 and 2
Stacked bar plot of cos2 of Dim1 + cos2 of Dim2 for each variable.  
The big bars are important for either Dim1 or Dim2.
```{r}
fviz_cos2(res.pca, choice = "var", axes = 1:2)
```

### Factor map: Coordinates and Cos2
The next plot shows for each variables in Dimensions 1 and 2 a vector from zero to the `coordinates` of each variable colord by `cos2`. High `cos2` is a good representation of the variable on the principal component. 

Arrows in the same direction means positive correlation of the variables,
orthogonal arrows mean no correlation between the variables and 
arrows in oposite directions meand negative correlation of the variables.

Correlation circle. Vectors that reach the circle are perfectly correlated with the Principal Components.
```{r}
fviz_pca_var(res.pca,
             col.var = "cos2", # Color by the quality of representation
             gradient.cols = c("darkorchid4", "gold", "darkorange"),
             repel = TRUE
             )
```

### Contribution of the variables to the first two PCs
The red dashed line on the graph indicates the expected average contribution. For a certain component, a variable with a contribution exceeding this benchmark is considered as important in contributing to the component.
```{r}
# Contributions of variables to PC1
a<-fviz_contrib(res.pca, choice = "var", axes = 1)
# Contributions of variables to PC2
b<-fviz_contrib(res.pca, choice = "var", axes = 2)
grid.arrange(a,b, ncol=2, top='Contribution of the variables to the first two PCs')
```

## PCA results for individuals
Extract:  
- Coordinate of each individual (sample) in each dimension  
- Squared cosine Cos2 of each individual in each dimension  
- Contribution of each individual to each dimension  
```{r}
ind <- get_pca_ind(res.pca)
```

### Coordinates of each individual colored by cos2
```{r}
fviz_pca_ind(res.pca,
             col.ind = "cos2", # Color by the quality of representation
             gradient.cols = c("darkorchid4", "gold", "darkorange"),
             repel = TRUE
            #  label = "none"
             )
```
```{r}
metadata <- metadata %>%
    filter(rownames(metadata) %in% rownames(matrix))
fviz_pca_ind(res.pca,
             geom.ind = "point", # show points only (nbut not "text")
             col.ind = metadata$lineage, # color by groups
             addEllipses = TRUE, # Concentration ellipses
             legend.title = "Lineage"
             )
```

res.pca is equal to coordinates of individuals.

```{r}
# Total contribution on PC1 and PC2
one <- fviz_contrib(res.pca, choice = "ind", axes = 1)
two <- fviz_contrib(res.pca, choice = "ind", axes = 2)
grid.arrange(one,two, ncol=2, top='Contribution of individuals to Dim1 and Dim2')
```

The next plot shows the variable vectors and the position of the individuals in PC1 and PC2
```{r}
autoplot(res.pca, 
    loadings=TRUE, 
    loadings.colour='darkorchid4', 
    loadings.label=TRUE, 
    loadings.label.size=3)
```