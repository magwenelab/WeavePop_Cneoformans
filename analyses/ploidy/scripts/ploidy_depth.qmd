---
title: "Ploidy detection with read depth"
author: "Claudia Zirión-Martínez"
date: "2025-02-21"
#format: 
#    PrettyPDF-pdf:
#        keep-tex: false
df-print: kable
editor: visual
embed-resources: true
format:
  html:
    code-overflow: scroll
    code-fold: true
---

```{r, output=FALSE}
library(tidyverse)
library(mixtools)
library(patchwork)
setwd("/FastData/czirion/Crypto_Diversity_Pipeline/analyses/ploidy/scripts")
```

```{r}
sample <- "ERS1142807"
dataset <- "Ashton"
path <- paste("../../../Crypto_", dataset,
    "/results/04.Intermediate_files/01.Samples/depth_quality/",
    sample,
    "/depth_by_windows.tsv",
     sep = "")
depth_by_windows_path <- paste("../../../Crypto_", 
  dataset, 
  "/results/01.Samples/plots/",
  sample,
  "/depth_by_windows.png",
  sep = "")
```

```{r, results="asis"}
cat(paste("##",sample, "\n"))
```

```{r, results="asis"}
cat(paste0("![](", depth_by_windows_path, ")", sep =""), "\n")
```
```{r, output=FALSE}
windows <- read_delim(path,
    delim = "\t",
    col_names = c("accession", "start", "end", "mean_depth", "norm_mean_depth", "smooth_norm_mean_depth"))
```

```{r, output = FALSE}
chrom_names <- read_csv(paste("../../../Crypto_",dataset,"/config/chromosomes.csv", sep =""))
chrom_names <- chrom_names %>%
    mutate(chromosome = str_pad(chromosome, 2, pad = "0"))%>%
    mutate(chromosome = as.factor(chromosome))
levels(chrom_names$chromosome) <- paste("chr", chrom_names$chromosome, sep="")
windows <- left_join(windows, chrom_names, by = "accession") 
```

```{r, message = FALSE, warning = FALSE}
ggplot(windows) +
  geom_histogram(aes(norm_mean_depth), binwidth = 0.01)+
  scale_y_continuous(trans = "log10") +
  scale_x_continuous(breaks = seq(0, max(windows$norm_mean_depth), by = 5),
                    limits = c(0,max(windows$norm_mean_depth) )) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))+
  labs(title = "Complete distribution of normalized mean depth (Log10)",
    y = "Count (Log10 transformation)",
    x = "Normalized mean depth")
```

### Filter

```{r}
#| code-fold: false
max_norm_mean_depth <- 5
```
```{r}
windows_filtered <- windows %>%
    filter(norm_mean_depth < max_norm_mean_depth )
```

```{r, message = FALSE, warning = FALSE}
ggplot(windows_filtered) +
  geom_vline(xintercept = c(0.5, 1, 1.5, 2), color = "darkgray", linetype = "solid") +
  geom_density(aes(norm_mean_depth, fill = chromosome, color = chromosome), alpha = 0.1) +
  theme_classic()+
  labs(title = "Density of Whole Genome Raw Data",
    y = "Density",
    x = "Normalized mean depth")
```

### Fit Gaussian Mixture Models to whole genome

```{r}
#| code-fold: false
max_iterations <- 100
```
```{r}
models_list <- list()
components <- c("k2", "k3", "k4", "k5")
for (comp in components) {
    models_list[[comp]] <- NULL
  }
```
```{r, error = TRUE, output = FALSE}
for (component in 2:5) {
    component_name <- paste("k", component, sep = "")

    print(paste("Analyzing with k=", component))

    tryCatch({
    models_list[[component_name]] <- normalmixEM(
          windows_filtered$norm_mean_depth, 
          k = as.integer(component), 
          maxit = max_iterations, 
          epsilon = 1e-8, 
          arbmean = TRUE, arbvar = TRUE)
    }, error = function(e) {
      message(paste("Error with", component, "components:", e$message))
    })
    # Calculate BIC
    num_data_points <- length(windows_filtered$norm_mean_depth)
    num_params <- component * 3 - 1  # Number of parameters in the model
    models_list[[component_name]][["bic_value"]] <- log(num_data_points) * num_params - 2 * models_list[[component_name]][["loglik"]]
}
```

### Whole genome density with optimal k
```{r}
bic_values <- sapply(models_list, function(model) model[["bic_value"]])
optimal_k_bic <-names(which.min(bic_values))

model <- models_list[[optimal_k_bic]]
plot(model, loglik=FALSE, density = TRUE, breaks = 400, 
       main2 = optimal_k_bic)
```

## Fit GMM to each chromosome with 2 to 5 components
```{r}
models_list <- list()
components <- c("k2", "k3", "k4", "k5")
for (chrom in levels(windows_filtered$chromosome)) {
  models_list[[chrom]] <- list()
  for (comp in components) {
    models_list[[chrom]][[comp]] <- NULL
  }
}
```
```{r, error = TRUE, output = FALSE }
for (chrom in levels(windows_filtered$chromosome)){
  for (component in 2:5) {
    component_name <- paste("k", component, sep = "")
    windows_filtered_chromosome <- windows_filtered %>%
      filter(chromosome == chrom)

    tryCatch({
    models_list[[chrom]][[component_name]] <- normalmixEM(
          windows_filtered_chromosome$norm_mean_depth, 
          k = as.integer(component), 
          maxit = max_iterations, 
          epsilon = 1e-8, 
          arbmean = TRUE, arbvar = TRUE)
    }, error = function(e) {
      message(paste("Error in chromosome", chrom, "with", component, "components:", e$message))
    })
    # Calculate BIC
    num_data_points <- length(windows_filtered_chromosome$norm_mean_depth)
    num_params <- component * 3 - 1  # Number of parameters in the model
    models_list[[chrom]][[component_name]][["bic_value"]] <- log(num_data_points) * num_params - 2 * models_list[[chrom]][[component_name]][["loglik"]]
  }
}
```

### Choose optimal number of components with BIC

```{r}
optimal_models <- list()
for (chrom in levels(windows_filtered$chromosome)) {
  optimal_models[[chrom]] <- list()
}
```

```{r}
for (chrom in names(models_list)) {
  bic_values <- sapply(models_list[[chrom]], function(model) model[["bic_value"]])
  optimal_k_bic <-names(which.min(bic_values))

  optimal_models[[chrom]] <- models_list[[chrom]][[optimal_k_bic]]
  # plot(optimal_models[[chrom]], loglik=FALSE, density = TRUE, breaks = 400, 
  #      main2 = paste(chrom, optimal_k_bic))
}
```

### Compare distributions of chromosomes

```{r}
list_dfs <- list()
for (chrom in levels(windows_filtered$chromosome)) {
  model <- optimal_models[[chrom]]

  data <- data.frame()

  for (i in 1:length(model$mu)) {
    x <- seq(0, model$mu[i] + 10*model$sigma[i], length.out = 100)
    y <- dnorm(x, model$mu[i], model$sigma[i]) * model$lambda[i]
    temp_data <- data.frame(x = x, y = y, component = as.factor(i), mean = model$mu[i])
    data <- rbind(data, temp_data)
  }
  list_dfs[[chrom]] <- data
}

combined_data <- bind_rows(list_dfs, .id = "chromosome")%>%
  group_by(chromosome)%>%
  mutate(k=max(as.numeric(component)))%>%
  ungroup()

```

```{r, message = FALSE, warning = FALSE}
r <- ggplot(windows_filtered) +
  geom_vline(xintercept = c(0.5, 1, 1.5, 2), color = "darkgray", linetype = "solid") +
  geom_density(aes(norm_mean_depth, fill = chromosome, color = chromosome), alpha = 0.3) +
  facet_wrap(~chromosome, ncol = 1, strip.position = "right")+
  labs(title = "Density of Raw Data",
    y = "Density",
    x = "Normalized mean depth")+
  theme_classic()+
  theme(legend.position = "none")

```
```{r, message = FALSE, warning = FALSE}
m <- ggplot(combined_data) +
  geom_vline(xintercept = c(0.5, 1, 1.5, 2), color = "darkgray", linetype = "solid") +
  geom_line(aes(x = x, y = y, linetype = component, color = chromosome)) +
  geom_text(aes(x = 3, y = 2, label= paste("k=", k, sep = "")))+
  scale_x_continuous(limits = c(0,4))+
  scale_color_discrete(guide = "none")+
  facet_wrap(~chromosome, ncol = 1, strip.position = "right")+
  labs(title = "Density of Components in Mixture Model",
       x = "Normalized mean depth",
       y = "Density")+
  theme_classic()+
  theme(legend.position = "bottom")
```

```{r}
#| fig.height: 10
#| fig.width: 7
r | m
```

```{r, message = FALSE, warning = FALSE}
#| fig.height: 10
#| fig.width: 7
ggplot(combined_data) +
  # geom_vline(xintercept = c(0.5, 1, 1.5, 2), color = "darkgray", linetype = "solid") +
  geom_vline(aes(xintercept = mean, color = component)) +
  geom_text(aes(x = mean + 0.05, y = max(y*3/4), label = round(mean, 2), color = component)) +
  geom_line(aes(x = x, y = y, color = component)) +
  geom_text(aes(x = 3, y = 2, label= paste("k=", k, sep = "")))+
  scale_x_continuous(limits = c(0,4))+
  facet_wrap(~chromosome, ncol = 1, strip.position = "right")+
  labs(title = "Density of Components in Mixture Model",
       x = "Normalized mean depth",
       y = "Density")+
  theme_classic()+
  theme(legend.position = "bottom")
```
